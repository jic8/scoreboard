# Мониторинг статусов роботов мойки
## Конфигурация проекта
Конфигурация проекта осуществляется через файл **config.toml**

1) Broker
	Шаблон:
    [[broker]]
    mqtt_url = "192.168.1.120"
    mqtt_port = 9001
    
*mqtt_url* - может быть в виде:

 - IP-адреса (Internet Protocol address) - это числовой адрес, используемый для идентификации устройства в сети. IP-адрес представляет собой последовательность чисел, разделенных точками, например, 192.168.0.1.
 - Доменного имени: Доменное имя (Domain Name) - это буквенное имя, используемое для идентификации ресурса в сети. Доменное имя обычно состоит из нескольких частей, разделенных точками, например, test.mosquitto.org. Оно может быть легче запомнить, чем IP-адрес, и обычно используется вместо него для доступа к ресурсам в сети.

*mqtt_port* - WebSocket(ws)

2. Для добавления нового брокера нужно указать его **url** и **port** websoket

2) Robots
*count* - количество роботов, которые будут показаны в  DOM дереве
*direction* - направление стрелки, которые будут показаны в  DOM дереве. Направление может быть: "L","R","T","D"
*slider_time* - количество секунд для изменения статуса робота на время работы.

## Развертывание приложения
Развертывание происходит через утилиту poetry (https://python-poetry.org/) 
Команда `install`считывает `pyproject.toml`файл из текущего проекта, разрешает зависимости и устанавливает их. 

> poetry install

## Структура приложения
`app.py` - нужен для запуска HTTP сервера.
В нем происходит чтение конфигурационного файла (получение данных брокеров, количество роботов на объекте). После чтения создается контекст для шаблонизатора Jinga
`static` - папка для хранения статики (js, css, images). 
`mqtt.min.js` - библиотека для работы с mqtt через ws
`static\js\mainClass.js` - основной js файл. В нем мы получаем параметры брокеров через `scriptTag`. Далее через создаем экземпляры класса MQTTClient для каждого брокера из конфигурационного файла `config.toml`.  Далее подписываемся на все сообщения от брокера. 
	При получении сообщения от брокера срабатывает `messageHandler`, который принимает 2 параметра:
	

 - Название топика - `robot/NUMBER_ROBOT/state`, где NUMBER_ROBOT - число
- Сообщение - это параметр робота, например:
 `mosquitto_pub -h localhost -t robot/3/state -m 1`, где 1 - это статус робота (в примере статус - "Занят")
 `mosquitto_pub -h localhost -t robot/3/washing-time-left -m 5`,  где 5 - это сколько времени осталось работать роботу.
	`messageHandler` - функция проверят структуры топика, если нет `robot/...`, то прекращает обрабатывать сообщение. 
	Далее проверяет опцию робота ( `state` или `washing-time-left`).
	Если опция робота `state`, то меняет в DOM состояние у робота, которого функция находит по (`[data-robot="${robotId}"]`), где `robotId` - номер робота. Обновляет содержимое span-a с классом `state`
	Возможные состояния робота:
	0 - Свободен
	1 - Занят
	2 - Недоступен
Если опция  робота `washing-time-left`, то происходит аналогичный функционал. Обновление содержимое span-a с классом `time`.
Возможные варианты отображения времени работать робота:
Сообщение = `*` -  "Мойка окончена"
Сообщение <  1 - "Менее минуты"
Сообщение  = любое число - срабатывает функция `formatMinutes`, которая возвращает `число + минут(склоняя по падежам)`

### Изменение состояние робота на его время его работы
Происходит через `restartInterval` - это функция работает на callback-ах. Вызывает функциею sliderEngine и задержку которая указана в файле `config.toml` миллисекунд (секунды в миллисекунды конвертирует функция `seconds_to_milliseconds` в файле `app.py`). Срабатывает на каждое корректное  сообщение от брокера.


## Запуск приложения
Для запуска приложения нужно открыть терминал в корневой директории проекта.
> cd tableProject/app
> flask run --host=0.0.0.0

